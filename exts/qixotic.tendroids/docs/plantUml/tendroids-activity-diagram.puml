@startuml tendroids-activity-diagram-v2

title Tendroids V2 Workflow - Spawn to Animate

|User Interface|
start
:User opens V2ControlPanel;
:Set spawn parameters\n(count, area, radius);

|Scene Manager|
:User clicks "Spawn Tendroids";
:V2SceneManager.create_tendroids();

|Builders|
:V2TendroidFactory.create_batch();
fork
  :Generate random positions;
fork again
  :Conform to sea floor height;
fork again
  :Create USD cylinder meshes;
  note right: CylinderGenerator\nwith "Deformable" tag
end fork

|Scene Manager|
:Create V2WarpTendroid for each;
:Wrap in V2TendroidWrapper;

|GPU Initialization|
:Initialize BatchWarpDeformer;
partition "GPU Setup" {
  :Allocate base_points array;
  :Allocate out_points array;
  :Allocate vertex_tendroid_ids;
  :Build batch arrays on GPU;
}

:Initialize BubblePhysicsAdapter;
partition "Bubble GPU Setup" {
  :Allocate bubble state arrays;
  :Allocate particle arrays;
  :Create GPU managers;
}

|UI Update|
:Display tendroid count;
:Enable animation controls;

|User Interface|
:User clicks "Start Animation";

|Animation Controller|
:V2AnimationController.start();
:Subscribe to update events;
:Initialize wave controller;
:Enable Fabric write path;

repeat
  :Wait for frame event (60 fps);
  
  |Wave System|
  :WaveController.update(dt);
  :Compute wave displacement (NumPy);
  :Generate wave_state dict;
  
  |Bubble System|
  :BubblePhysicsAdapter.update_gpu(dt);
  partition "GPU Bubble Physics" {
    :Launch BubblePhysics kernel;
    :Update all bubble states;
    :Integrate wave momentum;
  }
  :Download bubble states (single transfer);
  
  |Deformation System|
  :BatchWarpDeformer.update_states();
  :Update bubble_y, bubble_radius arrays;
  :Update wave_dx, wave_dz arrays;
  
  partition "GPU Deformation" {
    :Launch BatchDeformKernel;
    :Deform ALL vertices;
    :Apply wave displacement;
  }
  
  :Download vertices (single numpy());
  
  |Fabric Write|
  partition "Fabric GPU Write" {
    :Get cached Fabric stage;
    fork
      :Set mesh 0 points;
    fork again
      :Set mesh 1 points;
    fork again
      :Set mesh N points;
    end fork
  }
  
  |Visual Updates|
  :Update bubble sphere transforms;
  :Update bubble visibility;
  :Update particle positions;
  
  |Rendering|
  partition "OmniHydra" {
    :Read Fabric GPU data (zero-copy);
    :Rasterize geometry;
    :Evaluate materials;
    :Compute lighting;
    :Display frame;
  }

repeat while (Animation running?)

|User Interface|
:User clicks "Stop Animation";

|Animation Controller|
:V2AnimationController.stop();
:Unsubscribe from events;
:Log performance statistics;

if (User clicks "Clear All"?) then (yes)
  |Scene Manager|
  :Stop animation;
  :Clear bubble managers;
  :Destroy GPU resources;
  :Remove USD prims;
  :Reset state;
  stop
else (no)
  |User Interface|
  :Ready for restart;
  stop
endif

note right
  **GPU Bubble Physics Performance**: ~0.5ms
  - All bubbles in parallel
  - State machine on GPU
  - Wave integration on GPU
  
  **GPU Deformation Performance**: ~1.0ms
  - All vertices in parallel
  - Single kernel launch
  - 15 tendroids × 1200 vertices
  
  **Fabric GPU Write Performance**: ~0.8ms
  - 15 VtArray.Set() calls
  - Direct NumPy→Fabric
  - No tolist() overhead
  
  **OmniHydra Rendering**: ~5.7ms
  - Largest single cost
  - Zero-copy from Fabric
  - "Deformable" tag required
end note

legend right
  **Total Performance**:
  - Frame time: ~8.7ms
  - FPS: 115 (15 tendroids)
  - GPU utilization: 93%
  
  **GPU Optimizations**:
  - Batch deformation kernel
  - Fabric write path
  - GPU bubble physics
  - Single sync point
endlegend

@enduml

== Wave Motion System

=== Overview

The wave system provides realistic underwater current motion that affects both tendroids and bubbles. Tendroids sway with graduated motion (anchored base → free tip), while bubbles drift with the current.

**Performance**: ~0.5ms CPU overhead (NumPy vectorized)

**Implementation**: Sinusoidal wave function with spatial variation

=== Wave Behavior

==== Characteristics

The wave simulates ocean current with:

* **Periodic motion**: Regular wave cycles
* **Spatial variation**: Different phase per tendroid position
* **Graduated sway**: 0% at base → 100% at tip
* **Synchronized drift**: Bubbles follow wave momentum

==== Wave Function

Core sinusoidal calculation:

[source,python]
----
def calculate_wave(time, position, config):
    # Phase varies by position (spatial)
    phase = time * config.frequency + position.x * config.spatial_freq
    
    # Amplitude modulation
    amplitude = config.amplitude
    
    # Horizontal displacement
    dx = amplitude * sin(phase)
    dz = amplitude * cos(phase) * 0.5  # Secondary axis
    
    return (dx, dz)
----

**Result**: Smooth, continuous wave motion

=== WaveController

==== State Management

Tracks wave evolution over time:

[source,python]
----
class WaveController:
    def __init__(self, config: WaveConfig):
        self.config = config
        self._phase = 0.0
        self._cycle_time = 0.0
    
    def update(self, dt: float):
        # Advance phase
        self._phase += dt * self.config.frequency
        self._cycle_time += dt
        
        # Reset at 2π
        if self._phase >= 2 * pi:
            self._phase -= 2 * pi
            self._cycle_time = 0.0
----

==== Displacement Calculation

Per-tendroid wave displacement:

[source,python]
----
def get_displacement(self, tendroid_id, height_factor):
    """
    Get wave displacement for a point on a tendroid.
    
    Args:
        tendroid_id: Which tendroid
        height_factor: 0.0 (base) to 1.0 (tip)
    
    Returns:
        (dx, dz): Horizontal displacement
    """
    # Get tendroid position
    pos = self.tendroid_positions[tendroid_id]
    
    # Calculate wave at position
    dx, dz = self._calculate_wave(pos)
    
    # Apply graduated scaling
    # Base (0.0) gets no motion, tip (1.0) gets full motion
    dx *= height_factor * height_factor
    dz *= height_factor * height_factor
    
    return (dx, dz)
----

**Graduated Motion**: Quadratic scaling for natural anchored appearance

=== Configuration Parameters

[source,json]
----
{
  "frequency": 0.3,          // Wave cycles per second
  "amplitude": 8.0,          // Maximum sway distance
  "spatial_frequency": 0.01, // Phase variation by position
  "secondary_amplitude": 0.5 // Z-axis motion relative to X
}
----

==== Tuning Guide

**Gentle Sway**:
[source,json]
----
{
  "frequency": 0.2,
  "amplitude": 5.0
}
----

**Active Current**:
[source,json]
----
{
  "frequency": 0.5,
  "amplitude": 12.0
}
----

**Chaotic Motion**:
[source,json]
----
{
  "frequency": 0.8,
  "amplitude": 15.0,
  "spatial_frequency": 0.05
}
----

=== Integration with Deformation

==== Per-Vertex Application

Wave displacement applied to every vertex:

[source,python]
----
# In batch_deform_kernel
for vertex in tendroid:
    # Get height factor (0 at base, 1 at tip)
    h = vertex.y / tendroid.length
    
    # Fetch wave displacement for this tendroid
    dx = wave_dx[tendroid_id]
    dz = wave_dz[tendroid_id]
    
    # Apply graduated motion
    vertex.x += dx * h * h
    vertex.z += dz * h * h
----

**Result**: Smooth gradient from anchored base to swaying tip

=== Bubble Wave Integration

==== Three-Phase Motion

Bubbles transition through wave interaction phases:

**Phase 1: Initial Throw** (first 0.5 seconds)

* Strong wave momentum at spawn
* Rapid horizontal motion
* Simulates "catch" by current

**Phase 2: Transition** (next 1.0 seconds)

* Gradual blending
* Momentum → drift
* Smooth handoff

**Phase 3: Gentle Drift** (remainder)

* Pure wave-driven motion
* Synchronized with wave phase
* Natural floating appearance

==== GPU Wave Integration

Bubbles receive wave momentum in physics kernel:

[source,python]
----
# In bubble_physics_kernel
wave_influence = calculate_wave_at_position(
    position.y,
    tendroid_position,
    wave_phase
)

# Add to bubble velocity
velocity.x += wave_influence.x * dt * drift_strength
velocity.z += wave_influence.z * dt * drift_strength
----

=== Performance Characteristics

==== CPU Calculation

Wave computation is vectorized NumPy:

[source,python]
----
# Calculate for all tendroids at once
positions = np.array([t.position for t in tendroids])
phases = time * frequency + positions[:, 0] * spatial_freq

dx = amplitude * np.sin(phases)
dz = amplitude * np.cos(phases) * 0.5
----

**Performance**: ~0.5ms for 15 tendroids

==== Scaling

[cols="1,1"]
|===
|Tendroids |Wave Calc Time

|15 |0.5ms
|30 |0.9ms
|45 |1.3ms
|60 |1.7ms
|===

**Note**: Linear scaling, minimal overhead

=== Optimization Opportunities

==== GPU Wave Calculation

Move to deformation kernel:

**Current**:
[source]
----
CPU: Calculate wave → Upload to GPU
GPU: Read wave arrays → Apply
----

**Proposed**:
[source]
----
GPU: Calculate + Apply in kernel
----

**Potential Gain**: ~0.3-0.4ms

**Trade-off**: More complex kernel logic

=== UI Controls

Wave controls in V2ControlPanel:

* **Amplitude Slider**: Adjusts sway distance
* **Frequency Slider**: Controls wave speed
* **Enable/Disable**: Toggle wave motion

**Real-time Updates**: Changes apply immediately

=== Best Practices

==== Visual Quality

* Frequency 0.2-0.5 Hz looks most natural
* Amplitude 5-12 units for realistic underwater feel
* Spatial frequency 0.01 adds pleasant variation

==== Performance

* NumPy vectorization is critical
* Avoid Python loops for wave calculation
* Cache wave_state per frame

==== Integration

* Always provide wave_state to deformation
* Bubble physics needs wave synchronization
* Ensure graduated scaling for tendroids

=== Troubleshooting

==== No Wave Motion

Check:

* WaveController initialized?
* update() called each frame?
* Amplitude > 0?

==== Unrealistic Motion

* Lower frequency (<0.5 Hz)
* Reduce amplitude (<15 units)
* Adjust spatial_frequency

==== Bubble Drift Issues

* Verify wave_state passed to bubble physics
* Check wave momentum integration in GPU kernel
* Adjust drift_strength parameter

=== Future Enhancements

**Planned**:

* Multi-directional waves (X, Z independent)
* Variable wave patterns (surge/ebb cycles)
* Depth-based wave intensity
* Storm/calm modes

**Advanced**:

* FFT-based ocean simulation
* Wave-wave interference
* Current vortices
* Tidal effects

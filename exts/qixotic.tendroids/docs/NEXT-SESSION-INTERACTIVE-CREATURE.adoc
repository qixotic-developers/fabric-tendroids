= Next Session: Interactive Creature Implementation
:date: 2025-11-26
:status: Ready to Begin Phase 1
:toc:
:toclevels: 3

== Quick Status

**Project**: Tendroids V2 - GPU-Accelerated Underwater Animation

**Current State**: Production-ready at 115 fps with 15 tendroids

**Next Task**: Implement interactive mouse-controlled creature with tendroid repulsion

**Performance Budget**: ~7ms headroom (115 fps â†’ target >90 fps with interaction)

== What You're Building

=== The Vision

A player-controlled creature that swims through the tendroid forest with dynamic interactions:

1. **Mouse controls creature** (X-Z plane + button Y-axis)
2. **Tendroids repel** when creature approaches (spring physics: fast start, slow down)
3. **Bubbles pop** on collision with creature
4. **Defense mechanism** triggers when repulsion limit exceeded (alarm bubble swarm + color flash)

=== Implementation Approach

**Philosophy**: Incremental development, one small step at a time, tune by feel

**Phase 1 Goal**: Core mechanics (creature movement + repulsion + bubble collision)

**Phase 2 Goal**: Defense system (trigger + alarm bubbles + creature effect)

== Phase 1: Core Mechanics - First Implementation Step

=== Step 1: Mouse-Controlled Creature (START HERE)

**What to Build**:

Create `CreatureController` class that:
- Polls mouse position each frame
- Converts to world X-Z coordinates
- Handles mouse button Y-axis control (left=up, right=down)
- Applies simulation physics (velocity, acceleration, drag)
- Creates simple cylinder mesh for visual representation

**Specification** (agreed parameters):

[source,python]
----
# Creature dimensions
creature_radius = 6.0  # Units (for collision detection)
creature_length = 12.0  # Cylinder length

# Movement physics
max_speed = 40.0  # units/sec
acceleration_rate = 60.0  # units/secÂ²
drag_coefficient = 0.85  # Per-frame damping
y_button_speed = 25.0  # units/sec when button held

# Starting position
start_position = (0, 50, 0)  # Center of scene, mid-height
----

**Integration Point**: 

Add to `V2AnimationController._on_update()`:

[source,python]
----
# After wave update, before deformation
self.creature_controller.update(dt, mouse_state)
creature_pos = self.creature_controller.get_position()
----

**File Location**: `qixotic/tendroids/v2/controllers/creature_controller.py`

**Success Criteria**:
- âœ… Creature mesh visible in scene
- âœ… Moves smoothly with mouse (X-Z plane)
- âœ… Rises/falls with mouse buttons
- âœ… Has momentum/drift (simulation feel)
- âœ… Frame rate >110 fps (minimal overhead)

=== Step 2: Bubble Collision Detection

**What to Build**:

Add collision detection in `V2AnimationController._update_gpu_path()`:

[source,python]
----
# After bubble state download
creature_pos = self.creature_controller.get_position()
creature_radius = 6.0

for name, bubble_id in name_to_id.items():
    bubble_pos = positions[bubble_id]
    bubble_radius = radii[bubble_id]

    # Sphere-sphere collision
    distance = length(creature_pos - bubble_pos)
    if distance < (creature_radius + bubble_radius):
        # Trigger pop
        self.gpu_bubble_adapter.trigger_pop(bubble_id)
----

**Success Criteria**:
- âœ… Bubbles pop when creature touches them
- âœ… Works for both scenarios (creatureâ†’bubble, bubbleâ†’creature)
- âœ… Particle spray spawns on pop
- âœ… No performance impact

=== Step 3: Basic Repulsion

**What to Build**:

Create `RepulsionManager` class:

[source,python]
----
class RepulsionManager:
    def __init__(self):
        self.influence_radius = 20.0
        self.max_repulsion_angle = 30.0
        self.spring_strength = 5.0
        self.damping = 0.8

    def calculate_repulsion(self, creature_pos, tendroid):
        """
        Calculate repulsion displacement for tendroid.

        Returns: (dx, dy, dz) displacement vector
        """
        # Vector from tendroid base to creature
        to_creature = creature_pos - tendroid.position
        distance_2d = sqrt(to_creature.xÂ² + to_creature.zÂ²)

        # Only repel if within radius
        if distance_2d > self.influence_radius:
            return (0, 0, 0)

        # Spring force (fast start, slow down)
        # Force strongest when close, zero at radius
        force_factor = (1.0 - distance_2d / self.influence_radius) ** 2
        force = self.spring_strength * force_factor

        # Direction: away from creature (in X-Z plane)
        repel_direction = -normalize(to_creature.xz)

        # Apply damping for smooth motion
        displacement = repel_direction * force * self.damping

        return (displacement.x, 0, displacement.z)
----

**Integration**:

Modify `BatchWarpDeformer`:

[source,python]
----
# Add repulsion arrays
self.repulsion_dx_gpu = wp.zeros(num_tendroids, dtype=float)
self.repulsion_dz_gpu = wp.zeros(num_tendroids, dtype=float)

# In update_states()
for i, tendroid in enumerate(self.tendroids):
    dx, dy, dz = repulsion_manager.calculate_repulsion(
        creature_pos, tendroid
    )
    self.repulsion_dx_cpu[i] = dx
    self.repulsion_dz_cpu[i] = dz

# Upload to GPU
self.repulsion_dx_gpu.assign(self.repulsion_dx_cpu)
self.repulsion_dz_gpu.assign(self.repulsion_dz_cpu)
----

**Kernel Changes**:

[source,python]
----
@wp.kernel
def batch_deform_kernel(
    # ... existing parameters ...
    repulsion_dx: wp.array(dtype=float),
    repulsion_dz: wp.array(dtype=float),
):
    tid = wp.tid()
    tendroid_id = vertex_tendroid_ids[tid]

    # ... existing bubble deformation ...

    # Add repulsion (graduated like wave)
    h = height_factors[tid]  # 0 at base, 1 at tip
    influence = h * h  # Quadratic for anchored feel

    pos.x += repulsion_dx[tendroid_id] * influence
    pos.z += repulsion_dz[tendroid_id] * influence
----

**Success Criteria**:
- âœ… Tendroids bend away when creature approaches
- âœ… Fast initial movement, slows to stop
- âœ… Returns to neutral when creature leaves
- âœ… Smooth, natural motion
- âœ… Multiple tendroids can repel simultaneously

== Current Architecture Reference

=== Key Classes

**Scene Management**:
- `V2SceneManager` - Orchestrates everything
- `V2AnimationController` - Per-frame update loop
- `V2TendroidFactory` - Creates tendroids

**GPU Systems**:
- `BatchWarpDeformer` - Batch vertex deformation
- `batch_deform_kernel` - Warp GPU kernel
- `BubbleGPUManager` - GPU bubble physics
- `PopParticleGPUManager` - GPU particles

**Animation**:
- `WaveController` - Wave motion calculations

**File Structure**:

[source]
----
qixotic/tendroids/v2/
â”œâ”€â”€ animation/
â”‚   â””â”€â”€ wave_controller.py
â”œâ”€â”€ bubbles/
â”‚   â”œâ”€â”€ bubble_gpu_manager.py
â”‚   â””â”€â”€ bubble_physics_adapter.py
â”œâ”€â”€ controllers/
â”‚   â”œâ”€â”€ controller.py
â”‚   â””â”€â”€ warp_controller.py
â”œâ”€â”€ core/
â”‚   â”œâ”€â”€ batch_warp_deformer.py
â”‚   â””â”€â”€ batch_deform_kernel.py
â”œâ”€â”€ scene/
â”‚   â”œâ”€â”€ animation_controller.py
â”‚   â””â”€â”€ manager.py
â””â”€â”€ utils/
    â””â”€â”€ fabric_helper.py
----

=== Performance Baseline

Current (15 tendroids, 115 fps):

[source]
----
GPU deformation: 1.0ms
Fabric writes: 0.8ms
Bubble physics: 0.5ms
Particles: 0.2ms
Wave calc: 0.5ms (CPU)
Rendering: 5.7ms
Total: 8.7ms (115 fps)
----

Expected with creature (Phase 1):

[source]
----
+ Mouse input: 0.1ms
+ Collision checks: 0.5ms
+ Repulsion calc: 0.3ms
Total: ~9.6ms (~104 fps) âœ… Comfortable
----

=== Integration Points

**Where to Add Creature Code**:

1. **CreatureController**: New file `v2/controllers/creature_controller.py`

2. **RepulsionManager**: New file `v2/controllers/repulsion_manager.py`

3. **V2SceneManager**: Add creature initialization
   ```python
   def create_tendroids(...):
       # ... existing code ...
       
       # Create creature
       self.creature_controller = CreatureController(stage)
       self.repulsion_manager = RepulsionManager()
       
       # Pass to animation controller
       self.animation_controller.set_creature(
           self.creature_controller,
           self.repulsion_manager
       )
   ```

4. **V2AnimationController**: Add to update loop
   ```python
   def _on_update(self, event):
       # ... existing wave update ...
       
       # Update creature
       if self.creature_controller:
           self.creature_controller.update(dt, self._get_mouse_state())
           creature_pos = self.creature_controller.get_position()
           
           # Check bubble collisions
           self._check_bubble_collisions(creature_pos)
           
           # Calculate repulsion
           self._update_repulsion(creature_pos)
       
       # ... existing GPU bubble update ...
   ```

5. **BatchWarpDeformer**: Add repulsion arrays to state

=== Mouse Input (Omniverse Kit)

**Getting mouse position**:

[source,python]
----
import omni.appwindow

app_window = omni.appwindow.get_default_app_window()
mouse_pos = app_window.get_mouse_coords_pixel()

# Convert pixel coords to world position
# Need viewport dimensions and camera projection
import omni.kit.viewport.utility as vp_util

viewport = vp_util.get_active_viewport()
# ... camera ray casting for world position
----

**Getting mouse button state**:

[source,python]
----
from carb.input import MouseInput

# In update loop
left_button = input.is_mouse_button_pressed(MouseInput.LEFT_BUTTON)
right_button = input.is_mouse_button_pressed(MouseInput.RIGHT_BUTTON)
----

**Note**: May need to use omni.kit.viewport's camera to project mouse to world plane

=== USD Cylinder Creation

**Simple creature mesh**:

[source,python]
----
from pxr import UsdGeom, Gf, UsdShade

def create_creature_mesh(stage, position):
    """Create simple cylinder creature."""
    # Create cylinder
    cylinder = UsdGeom.Cylinder.Define(
        stage,
        "/World/Creature"
    )

    # Dimensions
    cylinder.CreateRadiusAttr().Set(6.0)
    cylinder.CreateHeightAttr().Set(12.0)

    # Position
    cylinder.AddTranslateOp().Set(Gf.Vec3d(*position))

    # Rotation (horizontal swimming orientation)
    cylinder.AddRotateXYZOp().Set(Gf.Vec3f(0, 0, 90))

    # Material (simple color for now)
    material = UsdShade.Material.Define(
        stage,
        "/World/Materials/Creature"
    )
    # ... OmniPBR shader with color

    return cylinder
----

== Phase 2 Preview (Future)

After Phase 1 works and feels good:

**Defense System Components**:

1. **DefenseManager** - Tracks repulsion limits, triggers defenses
2. **Alarm bubble spawning** - 60 small bubbles in upward cone
3. **Creature color flash** - Red tint fade over 0.5 seconds
4. **Cooldown system** - 8 seconds between defenses per tendroid

**Parameters** (already agreed):
- Defense threshold: 25Â° repulsion OR 2 seconds close proximity (<8 units)
- Alarm bubbles: 60 count, 50% normal size, burst over 0.5s
- Color change: Red flash, 0.5s fade to normal
- Cooldown: 8 seconds per tendroid

== Development Workflow

**Recommended Process**:

1. **Create files first** (creature_controller.py, repulsion_manager.py)
2. **Test creature movement** in isolation (no repulsion yet)
3. **Add bubble collision** (simple, quick win)
4. **Implement repulsion** (most complex part)
5. **Tune feel** (adjust spring constants, damping, speeds)
6. **Verify performance** (should stay >100 fps)

**File Sizes**: Keep each controller ~100-150 lines (manageable)

**Testing**: Use V2ControlPanel to spawn tendroids, then test creature

== Important Reminders

**File Locations**:
- Working dir: `C:\Dev\Omniverse\fabric-tendroids\exts\qixotic.tendroids`
- New controllers: `qixotic/tendroids/v2/controllers/`
- Documentation: `docs/`

**Code Style**:
- Controllers and helpers pattern
- GPU work in Warp kernels
- CPU work vectorized with NumPy when possible
- Clean, production-ready code

**Performance**:
- Target >90 fps throughout
- Profile after each addition
- Monitor GPU utilization

**Documentation**:
- Update docs/ as features are added
- Keep continuity docs in docs/continuity/
- AsciiDoc format (.adoc extension)

== Quick Reference Commands

**Spawn tendroids**:

[source,python]
----
# In Omniverse Script Editor
from qixotic.tendroids.v2.scene import V2SceneManager
manager = V2SceneManager()
manager.create_tendroids(count=15)
manager.start_animation(enable_profiling=True)
----

**Check FPS**:

[source,python]
----
profile_data = manager.get_profile_data()
print(f"Average FPS: {profile_data['avg_fps']:.1f}")
----

== Resources

**Key Documentation**:
- `docs/index.adoc` - Main documentation hub
- `docs/deformation-feature.adocinc` - How batch deformation works
- `docs/bubbles-feature.adocinc` - Bubble system details
- `docs/OPTIMIZATION_ANALYSIS.adoc` - Performance analysis

**Design Documents**:
- `docs/continuity/interactive-creature-design.adoc` - Full design spec
- `docs/continuity/2025-11-26-project-wrap-up.adoc` - Latest status

**PlantUML Diagrams**:
- `docs/plantUml/tendroids-component-diagram.puml` - Architecture
- `docs/plantUml/tendroid-sequence-diagram.puml` - Update flow

== First Task Summary

**Goal**: Get basic creature moving with mouse control

**Deliverable**: `creature_controller.py` with:
- Mouse position â†’ world position conversion
- Simulation physics (velocity, acceleration, drag)
- Mouse button Y-axis control
- Simple cylinder mesh visualization

**Success**: Creature swims smoothly through scene with mouse

**Time estimate**: 1-2 hours

**Next step after**: Add bubble collision detection (30 minutes)

'''

**Status**: Ready to begin Phase 1 Step 1 - Create CreatureController

**Performance target**: Maintain >90 fps (currently 115 fps)

**Development approach**: Incremental, test each piece, tune by feel

ðŸŽ® **Let's build some interactive gameplay!**


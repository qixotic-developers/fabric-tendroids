:doctitle: Swept Torus Solution for Tendroid Base
:revdate: 2025-11-11 09:40
:toc:
:toclevels: 3
:sectnums:
:idprefix:
:idseparator: -
:source-highlighter: pygments
include::C:\Dev\asciidoc-common\common-asciidoc-attributes.adoc[]

== Overview

The swept torus solution creates the trumpet-bell flared base of each Tendroid by sweeping a circle profile along a circular path while dynamically adjusting the profile radius. This produces a smooth, organic bell shape that transitions naturally into the cylindrical body.

=== Key Advantages

* **Smooth topology**: Single continuous mesh without seams
* **Configurable flare**: Adjustable bell diameter and height
* **Clean geometry**: Predictable vertex/face counts for GPU performance
* **Natural transition**: Seamless connection to cylinder segments

== Mathematical Foundation

=== Swept Surface Definition

A swept torus is created by sweeping a 2D profile curve along a 3D path curve:

----
Surface(u, v) = Path(u) + Radius(u) × Profile(v)
----

Where:

* `u ∈ [0, 1]` parametrizes position along the path
* `v ∈ [0, 2π]` parametrizes position around the profile circle
* `Path(u)` defines the sweep trajectory
* `Radius(u)` scales the profile at each path position
=== Circular Path

The base path is a horizontal circle in the XZ plane:

----
Path(u) = (path_radius × cos(2πu), 0, path_radius × sin(2πu))
----

This creates the circular footprint of the bell base.

=== Profile Circle

At each path position, the profile is a vertical circle in a local coordinate system:

----
Profile(v) = (0, profile_radius × sin(v), profile_radius × cos(v))
----

The profile must be rotated to align with the path tangent direction.

=== Dynamic Radius Function

The key to creating the bell flare is modulating the profile radius along the path:

----
Radius(u) = base_radius + (flare_radius - base_radius) × BlendFunction(u)
----

Where:

* `base_radius`: Radius at center (matches cylinder)
* `flare_radius`: Maximum radius at ground level
* `BlendFunction(u)`: Controls the flare profile shape
==== Blend Function Options

**Linear blend** (currently implemented):
----
BlendFunction(u) = u
----

**Smooth blend** (ease-in-out):
----
BlendFunction(u) = 3u² - 2u³
----

**Exponential blend** (more natural):
----
BlendFunction(u) = 1 - exp(-k × u)
----

The blend function determines how gradually the bell flares from center to edge.

== Implementation Details

=== Mesh Generation Algorithm

.Swept Torus Generation Process
[plantuml, swept-torus-algorithm, svg]
----
@startuml
start
:Initialize parameters\n(path_radius, base_radius, flare_radius);
:Calculate path segments (u_steps);
:Calculate profile segments (v_steps);
partition "Generate Vertices" {
  :For each path position u;
  :Calculate path point P(u);
  :Calculate path tangent T(u);
  :Calculate current radius R(u);
  :For each profile angle v;
  :Generate profile point in local frame;
  :Rotate by path tangent;
  :Translate to path position;
  :Store vertex;
}
partition "Generate Faces" {
  :For each quad in the grid;
  :Create two triangular faces;
  :Ensure correct winding order;
  :Store face indices;
}
:Create USD mesh;
:Set vertex positions;
:Set face indices;
:Compute normals;
stop
@enduml
----

=== Coordinate System Transformation

Each profile circle must be oriented perpendicular to the path tangent:

----
Tangent(u) = Path'(u) = (-sin(2πu), 0, cos(2πu))
Normal(u) = (0, 1, 0)  // Always vertical
Binormal(u) = Tangent × Normal
----

The profile point in world coordinates:

----
Vertex(u,v) = Path(u) + R(u) × [sin(v) × Normal + cos(v) × Binormal]
----

=== Vertex Indexing

For a mesh with `U` path segments and `V` profile segments:

----
Vertex index = u × (V + 1) + v
Total vertices = (U + 1) × (V + 1)
----
Each quad generates 2 triangular faces:

----
Face 1: [v0, v1, v2]
Face 2: [v0, v2, v3]

Where:
  v0 = u × (V+1) + v
  v1 = (u+1) × (V+1) + v  
  v2 = (u+1) × (V+1) + (v+1)
  v3 = u × (V+1) + (v+1)
----

=== Winding Order

Counter-clockwise winding for outward-facing normals:

----
Looking from outside the surface:
  Triangle vertices appear counter-clockwise
  Ensures correct lighting and culling
----

== Code Structure

=== Module Organization

----
qixotic/tendroids/geometry/
  ├── __init__.py              # Module exports
  ├── swept_torus_builder.py   # Main builder class
  └── swept_torus_helpers.py   # Math & geometry functions
----

=== Key Classes and Functions

==== SweptTorusBuilder

Orchestrates the swept torus creation process:

* `build()`: Main entry point, creates complete mesh
* `_create_base_mesh()`: Generates geometry and topology
* `_set_mesh_properties()`: Applies materials and display settings
==== Helper Functions

**Geometry generation**:

* `generate_swept_torus_vertices()`: Creates vertex positions
* `generate_swept_torus_faces()`: Creates face topology
* `compute_vertex_normals()`: Calculates smooth normals

**Mathematical utilities**:

* `calculate_path_point()`: Evaluates path curve at u
* `calculate_path_tangent()`: Computes tangent direction
* `calculate_profile_radius()`: Evaluates radius function
* `blend_linear()`: Linear interpolation
* `blend_smooth()`: Smooth ease-in-out

=== Class Relationships

.Swept Torus Class Diagram
[plantuml, swept-torus-classes, svg]
----
@startuml
class SweptTorusBuilder {
  - stage: Usd.Stage
  - parent_path: str
  - name: str
  - params: dict
  --
  + build() : Usd.Prim
  - _create_base_mesh() : tuple
  - _set_mesh_properties(mesh) : void
}

class SweptTorusHelpers {
  + generate_swept_torus_vertices() : list
  + generate_swept_torus_faces() : list
  + compute_vertex_normals() : list
  + calculate_path_point() : tuple
  + calculate_path_tangent() : tuple
  + calculate_profile_radius() : float
  + blend_linear() : float
  + blend_smooth() : float
}

SweptTorusBuilder ..> SweptTorusHelpers : uses
@enduml
----
== Configuration Parameters

=== Primary Parameters

[cols="1,1,3", options="header"]
|===
|Parameter |Type |Description

|`path_radius`
|float
|Radius of the circular path (bell footprint)

|`base_radius`
|float  
|Profile radius at center (matches cylinder)

|`flare_radius`
|float
|Maximum profile radius at ground level

|`height`
|float
|Vertical span of the bell shape

|`u_steps`
|int
|Number of segments around the path circle

|`v_steps`
|int
|Number of segments around each profile circle
|===

=== Derived Parameters

[cols="1,3", options="header"]
|===
|Parameter |Calculation

|`flare_ratio`
|`flare_radius / base_radius` (typically 2.0-3.0)

|`total_vertices`
|`(u_steps + 1) × (v_steps + 1)`

|`total_faces`
|`u_steps × v_steps × 2` (quads = 2 triangles)

|`profile_angle_step`
|`2π / v_steps`

|`path_parameter_step`
|`1.0 / u_steps`
|===
=== Typical Values

For a standard Tendroid base:

----
path_radius: 2.0      # 4.0 diameter footprint
base_radius: 0.5      # Matches cylinder radius
flare_radius: 1.5     # 3× flare ratio
height: 1.0           # 1 meter tall bell
u_steps: 32           # Smooth circle
v_steps: 16           # Adequate resolution
----

Results in:

* Vertices: 33 × 17 = 561
* Faces: 32 × 16 × 2 = 1,024 triangles
* Memory: ~22 KB for positions + ~8 KB for indices

== Performance Characteristics

=== Computational Complexity

[cols="1,2,3", options="header"]
|===
|Operation |Complexity |Notes

|Vertex generation
|O(U × V)
|Linear in mesh resolution

|Face generation
|O(U × V)
|Same as vertex count

|Normal computation
|O(U × V)
|Per-vertex calculation

|Total mesh creation
|O(U × V)
|Dominated by vertex operations
|===

=== Memory Footprint

Per swept torus base:

----
Positions: (U+1) × (V+1) × 3 floats × 4 bytes = 12(U+1)(V+1) bytes
Indices:   U × V × 2 triangles × 3 ints × 4 bytes = 24UV bytes
Normals:   (U+1) × (V+1) × 3 floats × 4 bytes = 12(U+1)(V+1) bytes

Total ≈ 24(U+1)(V+1) + 24UV bytes
----

For typical parameters (U=32, V=16):

* Positions: ~6.4 KB
* Indices: ~12.3 KB
* Normals: ~6.4 KB
* **Total: ~25 KB per base**
=== GPU Performance

* **Static geometry**: No per-frame updates needed
* **Low vertex count**: 561 vertices per base is negligible
* **Simple topology**: Regular grid structure
* **Batching friendly**: All bases use same vertex/index layout

For 15 Tendroids:

* Total vertices: 8,415
* Total faces: 15,360
* Combined memory: ~375 KB
* **GPU impact: Minimal** (modern GPUs handle millions of vertices)

== Integration with Tendroid System

=== Connection to Cylinder Segments

The swept torus base connects to the first cylinder segment:

----
Base top radius = base_radius
Cylinder bottom radius = base_radius
Connection point Y = base height
----

Seamless transition requires:

* Matching radii at connection point
* Aligned vertex rings (same V resolution)
* Consistent material application

=== Material Application

The base inherits the Tendroid's material:

----
Base material = Tendroid body material
Supports: diffuse, specular, translucency
Avoids: glass (GPU crash risk with dynamic geo)
----

=== Scene Hierarchy

----
/World/Tendroids/Tendroid_001
  ├── Base (Swept Torus Mesh)
  └── Body
      ├── Segment_00 (Cylinder)
      ├── Segment_01 (Cylinder)
      └── ...
----

Each component is independently addressable for animation or customization.
== Future Enhancements

=== Blend Function Library

Implement additional blend functions for varied flare profiles:

* **Bezier curves**: Precise artist control
* **Sine/cosine**: Natural organic shapes
* **Power functions**: Adjustable curvature

=== Adaptive Resolution

Dynamically adjust segment counts based on:

* View distance (LOD system)
* Curvature requirements
* Performance constraints

=== Deformation Support

Enable base participation in breathing animation:

* Radial pulsing at ground level
* Wave propagation through bell
* Coordinated with cylinder segments

=== Texture Mapping

Add UV coordinate generation:

----
U coordinate: Normalized around path circle
V coordinate: Normalized from base to top
Supports: Procedural textures, image mapping
----

== Troubleshooting

=== Common Issues

**Twisted or inverted normals**:

* Check winding order in face generation
* Verify tangent/binormal calculation
* Ensure consistent orientation

**Gaps at base-cylinder connection**:

* Verify radius matching at connection point
* Check Y-position alignment
* Ensure same V resolution for both

**Performance degradation**:

* Reduce U and V segment counts
* Check for unnecessary recomputation
* Profile vertex generation code

**Material issues**:

* Avoid glass materials (GPU crash risk)
* Use material safety system
* Test with simple diffuse first
=== Debug Visualization

Helpful visualization techniques:

**Wireframe mode**:

* Shows mesh topology clearly
* Reveals vertex/face issues
* Aids in resolution tuning

**Normal visualization**:

* Debug normal direction
* Check for flipped faces
* Verify smooth shading

**Color-coded parameters**:

* Map U parameter to red channel
* Map V parameter to green channel
* Visualize parameter space

== References

=== Mathematical Background

* *Swept Surface Theory*: https://en.wikipedia.org/wiki/Swept_surface
* *Torus Geometry*: https://mathworld.wolfram.com/Torus.html
* *Frenet-Serret Frames*: https://en.wikipedia.org/wiki/Frenet%E2%80%93Serret_formulas

=== USD Documentation

* *USD Mesh*: https://openusd.org/dev/api/class_usd_geom_mesh.html
* *Fabric API*: https://docs.omniverse.nvidia.com/kit/docs/usdrt.scenegraph/latest/
* *USDRT Geometry*: https://docs.omniverse.nvidia.com/kit/docs/usdrt.scenegraph/latest/usdrt.Gf.html

=== Related Techniques

* *Procedural Geometry*: Algorithmic mesh generation
* *Parametric Surfaces*: UV-based surface definition
* *Constructive Solid Geometry*: Boolean operations on primitives

== Glossary

[glossary]
Blend Function::
  Mathematical function controlling profile radius variation along path

Flare Ratio::
  Ratio of maximum radius to minimum radius (ground to center)

Path Curve::
  The trajectory along which the profile is swept

Profile Curve::
  The 2D shape swept along the path to create the surface

Swept Surface::
  3D surface created by moving a profile curve along a path

U Parameter::
  Parametrizes position along the path curve (0 to 1)

V Parameter::
  Parametrizes position around the profile curve (0 to 2π)

Winding Order::
  Sequence of vertices defining face orientation (clockwise/counter-clockwise)

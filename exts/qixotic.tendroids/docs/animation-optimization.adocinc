== Animation Optimization Strategies

=== Overview

The current breathing animation system calculates deformation offsets for each segment in real-time every frame. Since the deformation shape is constant and only its vertical position changes, we can precompute the deformation profile and use lookup tables to significantly reduce computational overhead.

=== Current Performance Analysis

==== Per-Frame Calculations

For each of 16 segments × 15 Tendroids = 240 segments:

1. Determine segment's position in wave (phase calculation)
2. Calculate radial scale factor at that phase
3. Apply scale transformation to segment

==== Redundant Work Identified

* Same wave shape calculated repeatedly
* Identical scale factors recomputed
* No caching of intermediate results
* Trigonometric functions computed per-frame

=== Optimization Strategy: Lookup Tables

==== Precompute Once

* Wave profile (amplitude vs. phase)
* Scale lookup table (256 entries)
* Interpolation coefficients

==== Per-Frame Runtime

* Calculate wave phase → stem:[O(1)]
* Lookup scale factor → stem:[O(1)]
* Apply cached transformation → stem:[O(1)]

**Expected speedup**: 2-3× faster per-segment updates

=== Deformation Profile Analysis

==== Wave Characteristics

The breathing wave is a traveling sine wave with consistent shape:

[stem]
++++
\text{Amplitude}(\phi) = \text{base\_scale} + \text{wave\_amplitude} \times \sin(\phi)
++++

Where:

* stem:[\phi \in [0, 2\pi\]] is position in the wave cycle
* `base_scale = 1.0` (neutral state)
* `wave_amplitude` determines breathing depth (typically 0.1-0.3)

==== Spatial Propagation

The wave travels vertically from base to tip:

[stem]
++++
\phi(\text{segment}, t) = 2\pi \times \left(\frac{\text{segment}_y}{\text{total\_height}} + t \times \text{frequency}\right)
++++

This creates the "breathing motion" effect as the wave moves up the cylinder.

==== Key Insight

**The wave SHAPE is constant** - only its Y-position changes over time.

This means:

* For any given phase value, the scale factor is always the same
* We can precompute all possible scale factors
* Runtime becomes a simple table lookup
* No trigonometry needed per-frame

=== Lookup Table Implementation

==== Table Structure

----
lookup_table[256] = {
  scale_0,   // phase = 0.000 × 2π
  scale_1,   // phase = 0.004 × 2π
  scale_2,   // phase = 0.008 × 2π
  ...
  scale_255  // phase = 0.996 × 2π
}
----

**Resolution**: 256 entries (8-bit precision)

* Sufficient for smooth animation
* Small memory footprint (1 KB)
* Fast indexing

==== Precomputation Code

Initialize once at startup:

[source,python]
----
def precompute_breathing_lookup():
    table = []
    for i in range(256):
        phase = (i / 256.0) * 2 * math.pi
        scale = 1.0 + wave_amplitude * math.sin(phase)
        table.append(scale)
    return table
----

**Cost**: 256 sine evaluations (< 1ms, done once)

==== Runtime Lookup Code

Per-frame for each segment:

[source,python]
----
def get_scale_factor(phase, lookup_table):
    # Normalize phase to [0, 1]
    normalized_phase = (phase % (2 * math.pi)) / (2 * math.pi)
    
    # Convert to table index
    index = int(normalized_phase * 256) % 256
    
    # Direct lookup - O(1)
    return lookup_table[index]
----

**No trigonometry** - just arithmetic and array indexing.

==== Interpolation Enhancement

For even smoother animation, add linear interpolation:

[source,python]
----
def get_scale_factor_interpolated(phase, lookup_table):
    normalized_phase = (phase % (2 * math.pi)) / (2 * math.pi)
    float_index = normalized_phase * 256
    
    # Integer and fractional parts
    index0 = int(float_index) % 256
    index1 = (index0 + 1) % 256
    frac = float_index - int(float_index)
    
    # Linear interpolation
    scale0 = lookup_table[index0]
    scale1 = lookup_table[index1]
    return scale0 + frac * (scale1 - scale0)
----

**Trade-off**:

* Smoother results
* Slightly more computation (still faster than sine)
* Negligible performance impact

=== Performance Comparison

==== Current Implementation

Per segment update:

----
1. Calculate phase:           ~5 ops
2. Compute sin(phase):         ~25 ops (EXPENSIVE)
3. Scale calculation:          ~3 ops
4. Transform application:      ~10 ops
----

**Total: ~43 operations per segment**

For 15 Tendroids × 16 segments = 240 segments:

* **10,320 operations per frame**
* Dominated by sine calculations

==== Optimized Implementation

Per segment update:

----
1. Calculate phase:           ~5 ops
2. Lookup table index:        ~3 ops
3. Array access:              ~1 op (FAST)
4. Transform application:     ~10 ops
----

**Total: ~19 operations per segment**

For 240 segments:

* **4,560 operations per frame**
* **2.3× fewer operations**

==== Real-World Impact

[cols="1,1,1,1"]
|===
|Configuration |Current (μs) |Optimized (μs) |Speedup

|1 Tendroid (16 seg) |70 |30 |2.3×
|15 Tendroids (240 seg) |1,050 |450 |2.3×
|30 Tendroids (480 seg) |2,100 |900 |2.3×
|===

**Frame budget saved**: ~600 μs for 15 Tendroids

At 60 FPS (16.67ms frame time):

* Current: 6.3% of frame budget
* Optimized: 2.7% of frame budget
* **Recovered: 3.6% frame budget**

=== Implementation Architecture

==== Module Structure

----
qixotic/tendroids/animation/
  ├── breathing_optimizer.py     # Lookup table manager
  └── breathing_helpers.py       # Original helpers (modified)
----

==== Class Design

.Optimization Class Diagram
[plantuml, breathing-optimization-classes, svg]
----
@startuml
class BreathingOptimizer {
  - lookup_table: list[float]
  - wave_amplitude: float
  - table_size: int
  --
  + __init__(wave_amplitude, table_size)
  + get_scale_factor(phase): float
  + get_scale_factor_interpolated(phase): float
  - _build_lookup_table(): list[float]
}

class BreathingAnimationController {
  - optimizer: BreathingOptimizer
  - segments: list
  --
  + update_breathing(time): void
  - _calculate_phase(segment, time): float
  - _apply_scale(segment, scale): void
}

BreathingAnimationController --> BreathingOptimizer : uses
@enduml
----

==== Integration Points

**Initialization** (once at startup):

[source,python]
----
# In BreathingAnimationController.__init__()
self.optimizer = BreathingOptimizer(
    wave_amplitude=0.2,
    table_size=256
)
----

**Update loop** (per frame):

[source,python]
----
# In update_breathing()
for segment in self.segments:
    phase = self._calculate_phase(segment, current_time)
    scale = self.optimizer.get_scale_factor(phase)
    self._apply_scale(segment, scale)
----

=== Advanced Optimizations

==== Multi-Resolution Tables

Different detail levels for different use cases:

----
High quality:   512 entries (smoother, 2 KB)
Standard:       256 entries (balanced, 1 KB)
Performance:    128 entries (faster, 512 bytes)
----

Select based on:

* Distance from camera
* Performance requirements
* Visual quality needs

==== SIMD Vectorization

Process multiple segments simultaneously using NumPy:

[source,python]
----
import numpy as np

phases = np.array([seg.phase for seg in segments])
normalized = (phases % (2 * np.pi)) / (2 * np.pi)
indices = (normalized * 256).astype(int) % 256
scales = lookup_table[indices]  # Vectorized!
----

**Potential speedup**: 4-8× with proper vectorization

==== GPU Acceleration Path

For future Warp kernel implementation:

[source,python]
----
# Warp kernel with lookup table
@wp.kernel
def breathing_deform_kernel(
    positions: wp.array(dtype=wp.vec3),
    lookup_table: wp.array(dtype=float),
    phases: wp.array(dtype=float),
    output: wp.array(dtype=wp.vec3)
):
    tid = wp.tid()
    phase = phases[tid]
    
    # Fast lookup in GPU shared memory
    normalized = phase / (2.0 * 3.14159) % 1.0
    index = int(normalized * 256.0) % 256
    scale = lookup_table[index]
    
    # Apply deformation
    pos = positions[tid]
    output[tid] = wp.vec3(pos[0] * scale, pos[1], pos[2] * scale)
----

**GPU advantages**:

* Parallel processing of all vertices
* Shared memory for lookup table (ultra-fast)
* Thousands of vertices per millisecond

=== Memory Considerations

==== Per-Tendroid Memory

**Current approach**:

* No additional memory overhead
* Recalculates everything each frame

**Optimized approach**:

----
Lookup table:     256 floats × 4 bytes = 1,024 bytes
Per Tendroid:     1 KB
For 15 Tendroids: 15 KB total
----

**Negligible memory cost** for significant performance gain.

==== Shared vs. Per-Instance

**Option 1: Shared table** (recommended):

* One table for all Tendroids
* 1 KB total memory
* All Tendroids use same wave shape

**Option 2: Per-instance tables**:

* Unique table per Tendroid
* 15 KB total memory
* Allows customized wave shapes per Tendroid

=== Implementation Roadmap

==== Phase 1: Basic Lookup

**Goals**:

* Implement `BreathingOptimizer` class
* Replace sine calculations with lookups
* Validate visual fidelity
* Measure performance improvement

**Tasks**:

1. Create `breathing_optimizer.py`
2. Add lookup table generation
3. Integrate with existing animation controller
4. Benchmark before/after performance

**Expected outcome**: 2-3× speedup

==== Phase 2: Interpolation & Polish

**Goals**:

* Add interpolated lookup for smoother animation
* Implement multi-resolution tables
* Add configuration options

**Tasks**:

1. Implement interpolated lookup method
2. Add table resolution parameter
3. Create quality presets (performance/balanced/quality)
4. Add runtime table swapping

**Expected outcome**: Smoother motion with minimal cost

==== Phase 3: Vectorization

**Goals**:

* Use NumPy for batch processing
* Process multiple segments simultaneously
* Further reduce Python overhead

**Tasks**:

1. Convert segment updates to NumPy arrays
2. Vectorize phase calculations
3. Vectorize lookup operations
4. Profile and optimize

**Expected outcome**: Additional 2-4× speedup

==== Phase 4: GPU Preparation

**Goals**:

* Design Warp kernel interface
* Prepare data structures for GPU
* Test with single Tendroid

**Tasks**:

1. Study Warp kernel documentation
2. Design vertex buffer layout
3. Implement CPU reference version
4. Create Warp kernel prototype

**Expected outcome**: Foundation for GPU acceleration

=== Testing Strategy

==== Visual Validation

Ensure optimized version matches original:

1. Run side-by-side comparison
2. Record animation at multiple speeds
3. Compare frame-by-frame
4. Validate amplitude accuracy

**Acceptance criteria**: < 1% visual difference

==== Performance Benchmarking

Measure improvement across scenarios:

[cols="1,2,2"]
|===
|Test Case |Metric |Target

|Single Tendroid |μs per frame |< 50 μs
|15 Tendroids |μs per frame |< 500 μs
|30 Tendroids |μs per frame |< 1000 μs
|Frame time impact |% of 16.67ms |< 3%
|===

==== Stress Testing

Push system to limits:

* 50+ Tendroids simultaneously
* Varying wave parameters
* Different table resolutions
* Profile memory usage

=== Conclusion

The lookup table optimization provides:

* **Significant performance improvement** (2-3× speedup)
* **Minimal memory overhead** (1 KB per table)
* **No visual degradation** (exact results with interpolation)
* **Simple implementation** (single new class)
* **Future-proof design** (compatible with GPU acceleration)

**Recommendation**: Implement Phase 1 for baseline performance improvement, then proceed to Phase 2 for enhanced quality.

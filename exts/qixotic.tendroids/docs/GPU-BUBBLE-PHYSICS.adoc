= GPU-Accelerated Bubble Physics
:date: 2025-11-25
:toc:

== Overview

New GPU-accelerated bubble physics system using Warp kernels to batch-process all bubble updates in parallel. Eliminates CPU-bound Python loops that were limiting performance to 15 tendroids @ 50fps.

**Expected Performance Gain:** 5-10x improvement based on vertex deformation benchmarks
- Python loops: 6.67ms/frame (150 fps)
- Warp GPU kernels: 0.68ms/frame (1480 fps)

== Architecture

=== New Files Created

[cols="1,2"]
|===
|File |Purpose

|`bubble_physics.py`
|Warp kernel for parallel bubble physics

|`bubble_gpu_manager.py`
|GPU array management and kernel launches

|`bubble_physics_adapter.py`
|Drop-in replacement interface for existing code
|===

=== How It Works

**CPU Version (Current):**

[source,python]
----
for tendroid in tendroids:
    state._update_rising(dt, wave)     # Python loop
    state._update_exiting(dt, wave)    # Per-bubble overhead
    state._update_released(dt, wave)   # Slow!
----

**GPU Version (New):**

[source,python]
----
gpu_manager.update_all(dt, config, wave_state)  # Single GPU batch!
phases, positions = gpu_manager.get_bubble_states()  # Download results
# Update visuals from GPU data
----

=== GPU Memory Layout

All bubble state lives in GPU arrays:

[source]
----
y_positions[N]       - Bubble Y position in cylinder
velocities[N, 3]     - X, Y, Z velocities
world_pos[N, 3]      - World space positions
phases[N]            - 0=idle, 1=rising, 2=exiting, 3=released, 4=popped
ages[N]              - Time since spawn
release_timers[N]    - Time since release
----

Tendroid properties (constant per bubble):

[source]
----
tendroid_pos[N, 3]   - Tendroid world positions
tendroid_length[N]   - Cylinder heights
----

== Integration Steps

=== Option 1: Gradual Migration (Recommended)

Use the adapter to test GPU physics alongside CPU version:

[source,python]
----
from qixotic.tendroids.v2.bubbles import create_gpu_bubble_system

# In scene manager initialization
self.gpu_bubbles = create_gpu_bubble_system(self.tendroids, bubble_config)

# In update loop
def _on_update(self, dt):
    wave_state = self.wave_controller.get_wave_state()

    # Update physics on GPU
    self.gpu_bubbles.update_gpu(dt, self.bubble_config, wave_state)

    # Get results
    bubble_positions = self.gpu_bubbles.get_bubble_positions()
    bubble_phases = self.gpu_bubbles.get_bubble_phases()

    # Update visuals (still uses USD Python API for now)
    for name, pos in bubble_positions.items():
        # Update bubble sphere transform
        pass
----

=== Option 2: Full GPU Pipeline

For maximum performance, bypass USD Python API entirely using Fabric/USDRT.

This requires:
1. Fabric attribute writers for transforms (next optimization phase)
2. Batch transform updates in single GPU kernel
3. Direct GPU → RTX renderer pipeline

== Performance Comparison

**Current Bottlenecks:**
- Bubble update loop: ~4.0ms @ 15 tendroids
- USD transform updates: ~2.0ms @ 15 tendroids
- Total: ~6.0ms/frame (166 fps theoretical)

**With GPU Bubble Physics:**
- Bubble update kernel: ~0.5ms @ 100 tendroids
- USD transform updates: ~2.0ms @ 15 tendroids (still CPU)
- Total: ~2.5ms/frame (400 fps theoretical)

**With Full GPU Pipeline (Future):**
- Bubble physics: ~0.5ms @ 100 tendroids
- Fabric transforms: ~0.3ms @ 100 tendroids
- Total: ~0.8ms/frame (1250 fps theoretical)

== Testing the GPU System

=== Quick Test

Modify `tests/test_warp_stress.py`:

[source,python]
----
# Add GPU bubble system test
from qixotic.tendroids.v2.bubbles import BubbleGPUManager

gpu_mgr = BubbleGPUManager(max_bubbles=100)

# Register bubbles
for i, t in enumerate(tendroids):
    gpu_mgr.register_bubble(i, t.position, t.length, spawn_y=20.0)

# Time GPU update
import time
start = time.perf_counter()
for _ in range(1000):
    gpu_mgr.update_all(dt=0.016, rise_speed=15.0,
                       released_rise_speed=25.0, spawn_height_pct=0.1)
elapsed = time.perf_counter() - start
print(f"GPU: {elapsed:.3f}s for 1000 updates @ 100 bubbles")
----

=== Expected Results

**CPU baseline:** 15 bubbles × 1000 updates = ~400ms
**GPU target:** 100 bubbles × 1000 updates = ~50ms

== 8x improvement even with more bubbles!

== Known Limitations

=== Current Implementation

1. **Simplified Physics:** GPU kernel implements core physics but some v1 features not yet ported:
   - Shape transition (elongation) - can add to kernel
   - Throw momentum - partially implemented
   - Particle spray - handled separately

2. **USD Bottleneck:** Still uses Python API for transform updates
   - Next phase: Fabric/USDRT for GPU → GPU pipeline

3. **Wave Calculations:** Wave state computed on CPU then passed to GPU
   - Can move entirely to GPU in future

=== Memory Constraints

- Fixed array size (max_bubbles) allocated upfront
- Each bubble: ~200 bytes GPU memory
- 100 bubbles = ~20KB (negligible on 24GB GPU)

== Next Optimization Phases

=== Phase 2: Fabric Transform Updates

Replace USD Python API with Fabric attribute writers:

[source,python]
----
# Current (CPU-bound)
translate_op.Set(Gf.Vec3d(x, y, z))  # Python → USD → GPU

# Target (GPU direct)
fabric_writer.write_transforms(positions_gpu)  # GPU → GPU
----

Expected gain: 3-5x for transform updates

=== Phase 3: Wave GPU Kernels

Move wave calculations to GPU:

[source,python]
----
@wp.kernel
def compute_wave_displacement_kernel(
    positions: wp.array(dtype=wp.vec3),
    time: float,
    wave_params: ...
):
    # Compute wave per-tendroid on GPU
    pass
----

Expected gain: 2-3x for wave motion

=== Phase 4: Complete GPU Pipeline

[source]
----
Python (minimal) → Warp Kernels → Fabric/USDRT → RTX Renderer
                       ↓              ↓              ↓
                  All Physics    Transforms    Ray Tracing
                   (GPU)          (GPU)          (GPU)
----

**Target: 100+ tendroids @ 60fps**

== File Organization

[source]
----
v2/bubbles/
├── bubble.py                    # Original V2Bubble (kept for reference)
├── bubble_manager.py            # CPU manager (current default)
├── bubble_physics.py            # NEW: Warp kernel
├── bubble_gpu_manager.py        # NEW: GPU array manager
├── bubble_physics_adapter.py    # NEW: Drop-in interface
└── __init__.py                  # Updated exports
----

== Debugging Tips

**Enable GPU timing:**

[source,python]
----
# Add to kernel launch
wp.synchronize()  # Wait for GPU
start = time.perf_counter()
wp.launch(kernel=..., ...)
wp.synchronize()
elapsed = time.perf_counter() - start
----

**Check GPU utilization:**

[source,bash]
----
# In terminal while running
nvidia-smi dmon -s u
----

**Verify kernel launches:**

[source,python]
----
# Enable Warp verbose mode
wp.config.verbose = True
----

== Summary

**Status:** GPU bubble physics implemented and ready for testing
**Integration:** Use `BubblePhysicsAdapter` for gradual migration
**Expected gain:** 5-10x for bubble physics, 2-4x overall fps
**Next step:** Test with 30+ tendroids to verify performance scaling

**Working Directory:** `C:\Dev\Omniverse\fabric-tendroids\exts\qixotic.tendroids`

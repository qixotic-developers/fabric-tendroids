== Environment System

=== Overview

The environment system creates the underwater scene foundation with sea floor terrain, lighting, and atmosphere. It provides the context for tendroids to exist naturally.

**Components**:

* Perlin noise terrain for sea floor
* Dome light for ambient illumination  
* Material assignments for realistic appearance
* Future: Caustic lighting, kelp, debris

=== Sea Floor

==== Terrain Generation

Procedural height map using Perlin noise:

[source,python]
----
def generate_sea_floor(size, resolution, noise_scale):
    """
    Create natural contoured sea floor.
    
    Args:
        size: (width, depth) in world units
        resolution: vertices per axis
        noise_scale: Perlin noise frequency
    
    Returns:
        height_map: 2D array of Y values
    """
    import numpy as np
    from noise import pnoise2
    
    height_map = np.zeros((resolution, resolution))
    
    for x in range(resolution):
        for z in range(resolution):
            # World position
            wx = (x / resolution) * size[0]
            wz = (z / resolution) * size[1]
            
            # Perlin noise
            height = pnoise2(
                wx * noise_scale,
                wz * noise_scale,
                octaves=4,
                persistence=0.5,
                lacunarity=2.0
            )
            
            height_map[x, z] = height * amplitude
    
    return height_map
----

**Result**: Natural-looking ocean floor with gentle hills and valleys

==== Mesh Creation

USD plane mesh with displaced vertices:

[source,python]
----
# Create USD mesh
floor_mesh = UsdGeom.Mesh.Define(stage, "/World/SeaFloor")

# Set vertices from height map
points = []
for x, z in grid:
    y = height_map[x, z]
    points.append((x, y, z))

floor_mesh.GetPointsAttr().Set(points)

# Set face connectivity
floor_mesh.GetFaceVertexIndicesAttr().Set(indices)
floor_mesh.GetFaceVertexCountsAttr().Set([4] * num_quads)
----

==== Material

Sandy appearance with subtle variation:

[source,python]
----
material = UsdShade.Material.Define(stage, "/World/Materials/SeaFloor")

# Base color: Sandy tan
shader.CreateInput("diffuse_color", Sdf.ValueTypeNames.Color3f).Set(
    (0.76, 0.70, 0.50)  # RGB
)

# Roughness: Matte surface
shader.CreateInput("roughness", Sdf.ValueTypeNames.Float).Set(0.9)

# Metallic: Non-metallic
shader.CreateInput("metallic", Sdf.ValueTypeNames.Float).Set(0.0)
----

==== Height Query Function

Tendroids use sea floor height for positioning:

[source,python]
----
def get_height_at(x: float, z: float) -> float:
    """
    Query sea floor height at world position.
    
    Args:
        x, z: World coordinates
    
    Returns:
        y: Height at that position
    """
    # Convert to grid coordinates
    grid_x = int((x + half_size) / grid_spacing)
    grid_z = int((z + half_size) / grid_spacing)
    
    # Clamp to bounds
    grid_x = max(0, min(grid_x, resolution - 1))
    grid_z = max(0, min(grid_z, resolution - 1))
    
    # Return cached height
    return height_map[grid_x, grid_z]
----

**Usage**: Tendroids anchor to this height during spawn

=== Lighting

==== Dome Light

Ambient underwater illumination:

[source,python]
----
dome_light = UsdLux.DomeLight.Define(stage, "/World/Lights/DomeLight")

# Intensity
dome_light.CreateIntensityAttr().Set(1000.0)

# Color: Subtle blue tint for underwater feel
dome_light.CreateColorAttr().Set((0.85, 0.9, 1.0))

# HDRI texture (optional)
dome_light.CreateTextureFileAttr().Set("underwater_hdri.hdr")
----

**Effect**: Soft, diffuse lighting from all directions

==== Distant Light (Optional)

Directional sunlight filtering through water:

[source,python]
----
distant_light = UsdLux.DistantLight.Define(
    stage, "/World/Lights/SunLight"
)

# Angle: 45° from above
distant_light.CreateAngleAttr().Set(45.0)

# Intensity: Dimmed by water
distant_light.CreateIntensityAttr().Set(500.0)

# Color: Warmer tone
distant_light.CreateColorAttr().Set((1.0, 0.95, 0.8))
----

**Effect**: Subtle directional shadows and highlights

=== Configuration

Environment settings from JSON:

[source,json]
----
{
  "sea_floor": {
    "size": [1000, 1000],
    "resolution": 100,
    "noise_scale": 0.02,
    "amplitude": 5.0,
    "base_height": -50.0
  },
  
  "lighting": {
    "dome_intensity": 1000.0,
    "dome_color": [0.85, 0.9, 1.0],
    "sun_intensity": 500.0,
    "sun_angle": 45.0
  },
  
  "atmosphere": {
    "fog_enabled": false,
    "fog_density": 0.01,
    "fog_color": [0.2, 0.3, 0.4]
  }
}
----

=== SeaFloorController

Manages floor lifecycle:

[source,python]
----
class SeaFloorController:
    @staticmethod
    def create_sea_floor(stage: UsdStage):
        """Create sea floor with terrain."""
        config = SeaFloorConfig.from_json()
        
        # Generate height map
        height_map = generate_perlin_terrain(
            size=config.size,
            resolution=config.resolution,
            noise_scale=config.noise_scale
        )
        
        # Create mesh
        create_floor_mesh(stage, height_map, config)
        
        # Apply material
        apply_floor_material(stage, config)
        
        # Cache for height queries
        SeaFloorHelper.cache_height_map(height_map)
----

=== Performance Impact

==== Creation Time

One-time cost during scene setup:

* Height map generation: ~50ms
* Mesh creation: ~20ms
* Material setup: ~10ms

**Total**: ~80ms (acceptable for one-time operation)

==== Runtime Cost

* **Zero** per-frame overhead
* Static geometry (no updates)
* Height queries are O(1) lookups

=== Future Features: Wave Action Phase 3 & 4

==== Phase 3: Caustic Lighting

Animated light patterns on sea floor:

**Concept**:
[source,python]
----
# Animated caustic texture
for frame in animation:
    # Update caustic pattern based on wave phase
    caustic_texture = generate_caustic_frame(
        wave_phase=wave_controller.phase,
        intensity=config.caustic_intensity
    )
    
    # Apply to sea floor material
    floor_material.inputs["emission_texture"] = caustic_texture
----

**Expected Overhead**: ~2-3ms per frame

**Visual Impact**: Dramatic underwater realism

==== Phase 4: Environmental Props

**Kelp Chains**:

* Procedural strand generation
* Wave-driven animation
* Clustered placement

**Floating Debris**:

* Small particles (leaves, sediment)
* Slow drift with wave
* Adds scene life

**Performance Budget**: ~1-2 fps impact

=== Best Practices

==== Sea Floor

* Resolution 100×100 is optimal (balance quality/memory)
* Noise scale 0.01-0.03 looks natural
* Amplitude 3-7 units for gentle terrain

==== Lighting

* Dome light essential for ambient
* Distant light optional (adds shadows)
* Blue tint (0.85, 0.9, 1.0) enhances underwater feel

==== Performance

* Create floor once at startup
* Cache height map for queries
* Don't regenerate terrain at runtime

=== Troubleshooting

==== Tendroids Floating

Check:

* get_height_at() returning correct values?
* Height map cached properly?
* Base height offset correct?

==== Dark Scene

* Increase dome_intensity (1000-2000)
* Add distant light
* Check material reflectance

==== Flat Terrain

* Increase noise_scale (0.02-0.05)
* Increase amplitude (5-10)
* Add more Perlin octaves

=== Integration Points

==== Tendroid Spawning

[source,python]
----
# During spawn
for position in spawn_positions:
    # Get floor height
    y = get_height_at(position.x, position.z)
    
    # Place tendroid on floor
    tendroid.position = (position.x, y, position.z)
----

==== Camera Positioning

Recommended camera setup:

* Position: (200, -20, 200)
* Look at: (0, 50, 0)
* FOV: 60-80°

**Result**: Good overview of tendroid forest

=== Advanced Topics

==== Multi-Layer Terrain

Stack multiple Perlin octaves:

[source,python]
----
height = 0
for octave in range(4):
    frequency = base_freq * (2 ** octave)
    amplitude = base_amp * (0.5 ** octave)
    height += pnoise2(...) * amplitude
----

**Effect**: More detailed, natural terrain

==== Dynamic Water Surface

Future enhancement for water plane:

* Animated normal maps
* Refraction/reflection
* Synchronized with wave motion

**Complexity**: High (requires shader work)

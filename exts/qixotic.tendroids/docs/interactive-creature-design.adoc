= Interactive Creature System - Design Document
:date: 2025-11-26
:status: Design Phase
:toc:
:toclevels: 3

== Project Vision

Add interactive gameplay elements to the Tendroids scene where a player-controlled creature swims through the tendroid forest, creating dynamic interactions and triggering defense mechanisms.

== Core Interaction Loop

[source]
----
Player moves creature → Approaches tendroid → Tendroid repels away
→ If repulsion limit exceeded → Defense mechanism triggers
→ Alarm bubbles spawn + Creature color change
----

== Feasibility Analysis

=== ✅ Definitely Doable

==== 1. Mouse-Controlled Creature

**Implementation**: Straightforward using omni.kit input system

* Mouse X-Z movement: ✅ Direct position mapping
* Mouse button Y-axis: ✅ Left=up, Right=down
* Smooth movement interpolation: ✅ Lerping between positions
* **Estimated effort**: Low-Medium

==== 2. Bubble Collision & Popping

**Implementation**: Simple sphere-sphere collision math

* Distance check: ✅ Already have all positions (creature + bubbles)
* Trigger phase transition: ✅ Set bubble phase to POPPED
* Spawn particles: ✅ Existing particle system
* **Estimated effort**: Low

==== 3. Basic Repulsion

**Implementation**: Distance-based force calculation

* Calculate vector from creature to tendroid base
* Apply repulsion force to vertices
* Integrate with batch deformation kernel
* **Estimated effort**: Medium

=== Design Questions & Answers

==== Creature Design

**Q1: Visual appearance?**

* **Decision**: Simple placeholder cylinder for now
* **Rationale**: Not yet sure what kind of creature we want
* **Future**: Can refine once gameplay feels right

**Q2: Movement characteristics?**

* **Decision**: Simulation-style (momentum, drift)
* **Rationale**: More natural feeling than arcade-style
* **Implementation**: Velocity + acceleration model

==== Repulsion Mechanics

**Q3: Repulsion behavior?**

* **Decision**: Start fast and slow down
* **Rationale**: Should look natural
* **Implementation**: Spring physics with damping

**Q4: Motion limits?**

* **To Define**: How far tendroids can bend (degrees from vertical)
* **To Define**: Visual feedback as limit approaches
* **Trigger**: Defense mechanism when limit exceeded

**Q5: Multiple tendroid handling?**

* **To Define**: Behavior when creature near multiple tendroids
* **Options**: Additive forces vs individual responses
* **To Refine**: During implementation phase

==== Defense Mechanism

**Q6: Trigger threshold?**

* **To Define**: Specific repulsion angle that triggers defense
* **To Define**: Time-based component (sustained contact duration?)
* **To Define**: Cooldown period between defenses

**Q7: Bubble stream details?**

* **Decision**: Dramatic swarm of bubbles
* **Visual**: Alarm signal to indicate defense triggered
* **To Define**: Exact count (20? 50? 100?)
* **To Define**: Emission pattern (burst vs stream)
* **To Define**: Visual differentiation from normal bubbles

**Q8: Creature effect?**

* **Decision**: Start with easiest implementation
* **Visual**: Color change (flash or sustained - TBD)
* **Future**: Could add movement effects (knockback, slow)
* **To Refine**: Based on what feels right

==== Bubble Collision Scenarios

**Collision types to handle**:

1. **Creature into bubble**: Creature moving, hits stationary/rising bubble
2. **Bubble into creature**: Bubble rising/drifting into stationary creature

**Decision**: Just pop the bubble for now (both scenarios)

**Future considerations**:
* Creature "feel" on collision (subtle slowdown?)
* Different pop effects based on collision velocity?

== Development Approach

=== Philosophy

**Incremental Development**: 

* Have an idea of where we're heading
* Take development one small-ish step at a time
* Future ideas may be affected by discoveries along the way
* Adapt based on what we learn

**Testing & Iteration**:

* Get each piece working before adding complexity
* Feel-based refinement (does it look/feel right?)
* Performance monitoring throughout

=== Proposed Implementation Phases

==== Phase 1: Core Mechanics (MVP)

**Goals**:
* Prove the core interaction loop works
* Establish performance baseline
* Get basic gameplay feeling right

**Deliverables**:

1. Simple creature mesh (cylinder placeholder)
2. Mouse X-Z + button Y control with simulation physics
3. Sphere-sphere collision detection
4. Basic repulsion (fast start, slow down)
5. Bubble popping on contact

**Success Criteria**:
* Creature moves smoothly with mouse
* Tendroids visibly react to creature proximity
* Bubbles pop when creature touches them
* Frame rate remains >90 fps

==== Phase 2: Defense System

**Goals**:
* Add consequence for over-interaction
* Create dramatic visual feedback
* Establish gameplay balance

**Deliverables**:

1. Repulsion limit detection (angle threshold)
2. Defense trigger mechanism (with cooldown)
3. Alarm bubble swarm spawning
4. Creature color change effect
5. Defense cooldown management

**Success Criteria**:
* Defense triggers at appropriate threshold
* Bubble swarm looks dramatic
* Color change is visible and clear
* System doesn't spam defenses

==== Phase 3: Polish (Future)

**Goals**:
* Visual refinement
* Gameplay tuning
* Quality-of-life improvements

**Ideas**:

1. Better spring-based repulsion physics
2. Creature swimming animation (tail waggle)
3. Improved creature model (actual fish)
4. Visual feedback (water ripples, creature trail)
5. Particle effects on defense trigger
6. Sound effects (if desired)

== Technical Architecture

=== New Components

==== CreatureController

**Responsibility**: Player input → Creature position

[source,python]
----
class CreatureController:
    def __init__(self):
        self.position = Vec3(0, 50, 0)  # Start mid-scene
        self.velocity = Vec3(0, 0, 0)
        self.acceleration = Vec3(0, 0, 0)
        
        # Physics parameters
        self.max_speed = 50.0  # units/sec
        self.acceleration_rate = 30.0
        self.drag = 0.9  # Velocity damping
        
    def update(self, dt, mouse_pos, buttons):
        # Mouse → target position
        # Buttons → Y velocity
        # Apply simulation physics
        # Update position
----

**Integration**: Called each frame by V2AnimationController

==== RepulsionManager

**Responsibility**: Creature proximity → Tendroid displacement

[source,python]
----
class RepulsionManager:
    def __init__(self):
        self.influence_radius = 15.0  # Units
        self.max_repulsion = 30.0  # Degrees from vertical
        self.spring_strength = 5.0
        self.damping = 0.85
        
    def calculate_repulsion(self, creature_pos, tendroid_pos):
        # Distance check
        # Spring force calculation (fast start, slow down)
        # Return repulsion vector
----

**Integration**: Feeds into BatchWarpDeformer state arrays

==== DefenseManager

**Responsibility**: Limit detection → Defense triggers

[source,python]
----
class DefenseManager:
    def __init__(self):
        self.defense_threshold = 25.0  # Degrees
        self.cooldown_time = 5.0  # Seconds
        self.alarm_bubble_count = 50  # Dramatic swarm
        
    def check_defense_trigger(self, tendroid_id, repulsion_angle):
        # Check if threshold exceeded
        # Verify cooldown expired
        # Trigger defense if conditions met
        
    def spawn_alarm_bubbles(self, tendroid_pos):
        # Create bubble swarm
        # Different visual from normal bubbles?
----

**Integration**: Triggered by AnimationController after repulsion calculation

=== Integration with Existing Systems

==== Deformation Pipeline

**Current**:
[source]
----
wave_dx/dz + bubble_y/radius → BatchDeformKernel → Vertices
----

**Modified**:
[source]
----
wave_dx/dz + bubble_y/radius + repulsion_dx/dz/dy 
→ BatchDeformKernel → Vertices
----

**Changes needed**:

1. Add repulsion arrays to BatchWarpDeformer
2. Calculate repulsion per frame (CreatureController + RepulsionManager)
3. Update kernel to apply repulsion force
4. Combine with existing wave + bubble deformation

==== Collision Detection

**New collision checks each frame**:

[source,python]
----
# Bubble collision
for bubble in active_bubbles:
    if distance(creature_pos, bubble_pos) < (creature_radius + bubble_radius):
        bubble.set_phase(POPPED)
        
# Tendroid proximity (for repulsion)
for tendroid in tendroids:
    distance = distance(creature_pos, tendroid_pos)
    if distance < repulsion_radius:
        apply_repulsion(tendroid, creature_pos)
----

**Performance consideration**: 15 tendroids + ~15 bubbles = 30 checks per frame (negligible)

== Performance Estimates

=== Current Baseline

* **FPS**: 115 with 15 tendroids
* **Frame time**: 8.7ms
* **Headroom**: ~7ms to 60 fps

=== Predicted Overhead

[cols="2,1,2"]
|===
|System |Time |Notes

|Mouse input polling
|+0.1ms
|Once per frame

|Collision checks
|+0.5ms
|30 sphere-sphere checks

|Repulsion calculation
|+0.3ms
|CPU, vectorized if possible

|Defense bubble spawns
|+0.2ms
|Only when triggered (rare)

|**Total added**
|**+0.9ms**
|Steady state

|**New frame time**
|**~9.6ms**
|~104 fps

|===

**Conclusion**: Comfortable performance margin, well above 60 fps target

=== Optimization Opportunities

If needed:

1. **GPU repulsion calculation**: Move to batch kernel (~0.2ms savings)
2. **Spatial partitioning**: Skip distant collision checks (~0.1ms savings)
3. **LOD**: Reduce tendroid segments when not in view (~variable)

**Not needed immediately** - current estimates are acceptable

== Open Questions & Refinement Needed

=== Immediate (Phase 1)

1. **Creature size**: Radius for collision detection (5 units? 8 units?)
2. **Movement speed**: Max speed in units/sec (30? 50? 100?)
3. **Repulsion radius**: How close triggers repulsion (10 units? 15 units?)
4. **Spring constants**: Tuning for "fast start, slow down" feel
5. **Collision handling**: Exact behavior when creature hits bubble

=== Phase 2 Specifics

1. **Defense threshold**: Exact angle that triggers defense (20°? 30°?)
2. **Cooldown duration**: Time between defenses per tendroid (5s? 10s?)
3. **Bubble swarm count**: How many alarm bubbles (20? 50? 100?)
4. **Bubble swarm pattern**: Burst outward? Rise in cluster? Spray in arc?
5. **Color change**: What color? Flash duration? Fade speed?

=== Technical Details

1. **Input smoothing**: How much interpolation on mouse movement?
2. **Y-axis speed**: Button hold → how fast vertical movement?
3. **Boundary handling**: What happens at scene edges?
4. **Bubble differentiation**: Visual difference for alarm bubbles?

== Next Steps

=== Design Refinement Session

**Before any code**:

1. Define exact interaction ranges (distances, angles, speeds)
2. Sketch repulsion force curve (fast → slow behavior)
3. Specify defense trigger conditions precisely
4. Plan bubble swarm visual appearance
5. Choose color change implementation

**Output**: Specification document with all numbers defined

=== Implementation Plan

**Once design locked**:

1. Create CreatureController (mouse → position)
2. Add collision detection (creature ↔ bubbles)
3. Implement basic repulsion (tendroid bending)
4. Test & tune feel
5. Add defense trigger
6. Implement alarm bubbles
7. Add color change effect
8. Polish & balance

== Design Philosophy

**Iterative Feel-Based Development**:

* Get it working simply first
* Test with real interaction
* Adjust numbers based on feel
* Add complexity only when needed

**Performance-Conscious**:

* Monitor fps throughout
* Keep >90 fps as target
* Optimize only if needed

**Extensible Design**:

* Build for current features
* Keep future enhancements possible
* Don't over-engineer early

== Success Criteria

**Phase 1 Complete When**:

* ✅ Creature moves naturally with mouse
* ✅ Tendroids bend away from creature
* ✅ Bubbles pop on contact
* ✅ Performance >90 fps
* ✅ Interaction feels responsive and natural

**Phase 2 Complete When**:

* ✅ Defense triggers at appropriate times
* ✅ Alarm bubbles look dramatic
* ✅ Color change is clear
* ✅ Cooldowns prevent spam
* ✅ Gameplay feels balanced

'''

**Status**: Design phase - Ready to refine specific interaction parameters

**Next**: Define exact numbers for distances, speeds, angles, thresholds


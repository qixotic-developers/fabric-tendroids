@startuml tendroid-sequence-diagram

title Tendroid Creation and Animation Flow

actor User
participant "Control\nPanel" as UI
participant "Scene\nManager" as SM
participant "Tendroid\nFactory" as TF
participant "Tendroid" as T
participant "Tendroid\nBuilder" as TB
participant "Cylinder\nGenerator" as CG
participant "Warp\nDeformer" as WD
participant "Material\nSafety" as MS
participant "Breathing\nAnimator" as BA
participant "Animation\nController" as AC
participant "USD\nStage" as USD

== Tendroid Creation ==

User -> UI: Click "Spawn Tendroids"
activate UI

UI -> SM: create_single_tendroid(\n  position, radius, length,\n  num_segments, params)
activate SM

SM -> TF: create_single(\n  stage, params)
activate TF

TF -> T: __init__(\n  name, position,\n  radius, length,\n  num_segments)
activate T

T -> T: Initialize attributes:\n  - position, size\n  - component refs (None)\n  - state flags

TF -> T: create(stage, parent_path)

T -> TB: create_in_stage(\n  tendroid, stage,\n  parent_path)
activate TB

TB -> TB: _create_usd_geometry(\n  tendroid, stage,\n  parent_path)

TB -> USD: Define base Xform at path
activate USD
USD --> TB: Xform created
deactivate USD

TB -> CG: create_tendroid_cylinder(\n  stage, mesh_path,\n  radius, length,\n  segments, resolution,\n  flare params)
activate CG

CG -> CG: Calculate flare height\nand deform_start_height

CG -> USD: Create UsdGeom.Mesh
activate USD
USD --> CG: Mesh prim
deactivate USD

CG -> CG: Generate vertices:\n  - Flared base\n  - Cylindrical body

CG -> USD: Set vertices,\n  normals, topology
activate USD
deactivate USD

CG --> TB: (mesh_prim, vertices,\n  num_segs, rad_res,\n  deform_start)
deactivate CG

TB -> TB: Store mesh_prim,\n  vertices,\n  deform_start_height

TB -> TB: _initialize_components(\n  tendroid)

TB -> MS: MaterialSafetyChecker(\n  mesh_path)
activate MS

MS -> MS: Initialize:\n  - check_counter = 0\n  - is_glass_material = False

MS -> MS: check_material()

MS -> USD: Get material binding
activate USD
USD --> MS: Material (if any)
deactivate USD

MS -> MS: Check for glass keywords

MS --> TB: MaterialSafetyChecker instance
deactivate MS

TB -> T: Store material_safety

TB -> T: mesh_updater = MeshVertexUpdater(\n  mesh_prim)

TB -> WD: WarpDeformer(\n  vertices,\n  deform_start_height)
activate WD

WD -> WD: Convert vertices to\n  Warp arrays (CUDA):\n  - original_positions\n  - deformed_positions

WD --> TB: WarpDeformer instance
deactivate WD

TB -> T: Store warp_deformer

TB -> BA: BreathingAnimator(\n  length,\n  deform_start_height,\n  wave_speed,\n  bulge_length_percent,\n  amplitude,\n  cycle_delay)
activate BA

BA -> BA: Calculate:\n  - bulge_length\n  - travel_time\n  - cycle_duration

BA --> TB: BreathingAnimator instance
deactivate BA

TB -> T: Store breathing_animator

TB -> T: is_created = True

TB -> TB: _log_creation_status(\n  tendroid)

alt Material is glass
  TB -> TB: Log error:\n  "GLASS MATERIAL DETECTED\n   Animation BLOCKED"
else Material is safe
  TB -> TB: Log info:\n  "Created with animation enabled"
end

TB --> T: True (success)
deactivate TB

T --> TF: True
deactivate T

TF --> SM: Tendroid instance
deactivate TF

SM -> SM: tendroids = [tendroid]

SM -> AC: set_tendroids([tendroid])
activate AC
AC -> AC: self.tendroids = [tendroid]
AC --> SM
deactivate AC

SM --> UI: True (success)
deactivate SM

UI -> UI: Update status display:\n  "Created: D=20.0, L=100.0..."

UI --> User: Tendroid visible in viewport
deactivate UI

== Animation Start ==

User -> UI: Click "Start Animation"
activate UI

UI -> SM: start_animation()
activate SM

SM -> AC: start()
activate AC

AC -> AC: Subscribe to\n  update event stream

AC -> AC: is_running = True

AC --> SM
deactivate AC

SM --> UI
deactivate SM

UI -> UI: Update status:\n  "Animation started"

UI --> User: Breathing begins
deactivate UI

== Animation Update Loop ==

loop Every Frame

  AC -> AC: _on_update(event)
  activate AC
  
  AC -> AC: Extract dt from event\n  (default 1/60)
  
  loop For each Tendroid
    
    AC -> T: update(dt)
    activate T
    
    alt is_created and is_active
      
      T -> T: Check all components\n  initialized
      
      T -> MS: should_check_now()
      activate MS
      MS -> MS: check_counter++
      alt check_counter >= check_interval
        MS -> MS: check_counter = 0
        MS --> T: True
      else
        MS --> T: False
      end
      deactivate MS
      
      alt Should check now
        T -> MS: check_material()
        activate MS
        MS -> USD: Get material binding
        activate USD
        USD --> MS: Material
        deactivate USD
        MS -> MS: Check keywords
        alt Glass detected
          MS -> MS: is_glass_material = True\n  animation_disabled_reason = ...
          MS -> MS: Log error:\n  "GLASS MATERIAL DETECTED"
        else
          MS -> MS: is_glass_material = False
        end
        MS --> T: is_safe
        deactivate MS
      end
      
      T -> MS: is_safe_for_animation()
      activate MS
      MS --> T: not is_glass_material
      deactivate MS
      
      alt Material is safe
        
        T -> BA: update(dt)
        activate BA
        BA -> BA: time += dt\n  cycle_time = time % cycle_duration
        
        alt In delay period
          BA --> T: {wave_center: -1000,\n   active: False}
        else Active animation
          BA -> BA: calculate_wave_position(\n  cycle_time, speed,\n  deform_start_height)
          BA --> T: {wave_center,\n   bulge_length,\n   amplitude,\n   active: True}
        end
        deactivate BA
        
        alt Wave is active
          
          T -> WD: update(\n  wave_center,\n  bulge_length,\n  amplitude)
          activate WD
          
          WD -> WD: Launch Warp kernel:\n  deform_breathing_bulge(\n    original_positions,\n    deformed_positions,\n    wave_center,\n    bulge_length,\n    amplitude,\n    deform_start_y)
          
          note right of WD
            GPU kernel processes
            all vertices in parallel:
            1. Skip if below deform_start_y
            2. Calculate distance from wave_center
            3. Apply raised cosine envelope
            4. Compute radial displacement
            5. Write to deformed_positions
          end note
          
          WD -> WD: Copy deformed_positions\n  back to CPU (numpy)
          
          WD -> WD: Convert numpy to\n  list of Gf.Vec3f
          
          WD --> T: deformed_vertices
          deactivate WD
          
          T -> T: mesh_updater.update_vertices(\n  deformed_vertices)
          
          T -> USD: Set points attribute
          activate USD
          deactivate USD
          
        end
        
        T -> BA: should_emit_bubble()
        activate BA
        BA -> BA: Check if wave\n  passed 95% of length
        alt Should emit
          BA -> BA: last_bubble_time = time
          BA --> T: True
        else
          BA --> T: False
        end
        deactivate BA
        
        alt Should emit bubble
          T -> T: _emit_bubble()
          note right of T
            Phase 2 feature
            Currently just logs
          end note
        end
        
      else Material unsafe
        note right of T
          Animation completely blocked
          No updates performed
        end note
      end
      
    end
    
    T --> AC
    deactivate T
    
  end
  
  AC --> AC
  deactivate AC
  
end

@enduml
